import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by andy on 10/22/16.
 */

class Node<T> {
    T data;
    Node next;

    Node (T data) {
        this.data = data;
    }
}

public class LockFreeQueue<T> {
    Node<T> head;
    Node<T> tail;

    public LockFreeQueue() {
        head = new Node<T>(null);
        tail = head;
    }

    public void enqueue (T obj) throws InterruptedException {
        if (obj == null) throw new NullPointerException();
        Node<T> newNode = new Node<T>(obj);
        while (true){
            if (tail.next==null) {
                tail.next = newNode; //set reference to the new node
                break;
            } else {
                tail = tail.next; //move the tail to the last node
            }
        }
        tail = newNode; //set tail to the new node
    }

    public boolean dequeue() throws InterruptedException {
        while (true) {
            if (head == tail){ //is queue empty or tail is falling behind
                if (head.next == null){ //is queue empty
                    return false; //queue is empty
                } else {
                    tail = tail.next; //tail is falling behind, move the tail to the next node
                }
            } else {
                head = head.next; //swing head to the next node
                break;
            }
        }
        return true;
    }
}
